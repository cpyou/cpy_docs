理解client-go

[TOC]

# 4.2 client-go 使用示例

## 4.2.1 client-go 集群内认证配置

​	下面通过client-go 来编写一小段代码，完成认证后查询 default 命名空间下的 pod，并将其名字打印出来。

### 1. 准备项目

```shell
cd ~/MyOperatorProjects
mkdir client-go-examples
cd client-go-examples
go mod init github.com/daniel-hutao/client-go-examples
# go: creating new go.mod: module github.com/daniel-hutao/client-go-examples
mkdir in-cluster-configuration
cd in-cluster-configuration
touch main.go
```



## 2. 实现业务逻辑

```go
package main

import (
    "context"
    "log"
    "time"

    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/kubernetes"
    "k8s.io/client-go/rest"
)

func main() {
    config, err := rest.InClusterConfig()
    if err != nil {
        log.Fatal(err)
    }

    clientset, err := kubernetes.NewForConfig(config)
    if err != nil {
        log.Fatal(err)
    }

    for {
        pods, err := clientset.CoreV1().Pods("default").List(context.TODO(), metav1.ListOptions{})
        if err != nil {
            log.Fatal(err)
        }
        log.Printf("There are %d pods in the cluster\n", len(pods.Items))
        for i, pod := range pods.Items {
            log.Printf("%d -> %s/%s", i+1, pod.Namespace, pod.Name)
        }
        <-time.Tick(5 * time.Second)
    }
}

```

## 3.编写Dockerfile

```dockerfile
FROM busybox
COPY ./in-cluster /app
ENTRYPOINT /app
```



## 4.编译代码

```shell
go mod tidy
cd in-cluster-configuration
GOOS=linux go build -o ./in-cluster .
```

## 5.容器化并加载到kind环境

```shell
docker build -t in-cluster:v1 .
kind load docker-image in-cluster:v1 --name=dev
```

## 6.创建ClusterRoleBinding

```shell
kubectl create clusterrolebinding default-view --clusterrole=view --serviceaccount=default:default
```

## 7.启动Pod

```shell
kubectl run -i in-cluster --image=in-cluster:v1
```



# 4.2.2 client-go 集群外认证配置

集群内Pod实现认证的核心原理是容器内自动挂载了token和ca.crt两个文件。

集群外向kubectl访问API Server 一样，利用kubeconfig文件实现认证。

## 1. 准备目录

```shell
cd ~/MyOperatorProjects/client-go-examples
mkdir out-of-cluster-configuration
cd out-of-cluster-configuration
touch main.go

```

2.实现业务逻辑

```go
package main

import (
	"context"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
	"log"
	"path/filepath"
	"time"
)

func main() {
	homePath := homedir.HomeDir()
	if homePath == "" {
		log.Fatal("failed to get the home directory")
	}

	kubeconfig := filepath.Join(homePath, ".kube", "config")

	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		log.Fatal(err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		log.Fatal(err)
	}

	for {
		pods, err := clientset.CoreV1().Pods("default").List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatal(err)
		}
		log.Printf("There are %d pods in the cluster\n", len(pods.Items))
		for i, pod := range pods.Items {
			log.Printf("%d -> %s/%s", i+1, pod.Namespace, pod.Name)
		}
		<-time.Tick(5 * time.Second)
	}
}

```

## 3.编译运行

```shell
go mod tidy
cd out-of-cluster-configuration
go build -o out-of-cluster
./out-of-cluster
```

